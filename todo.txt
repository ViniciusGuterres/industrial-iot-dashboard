FASE 1: Infraestrutura Cloud (Setup AWS) ‚òÅÔ∏è
[ X ] Configurar AWS IoT Core:

Criar uma "Thing" chamada Sentinel-Gateway.

Gerar e baixar os certificados (Certificate, Private Key, Root CA). Guarde isso!

Criar uma Policy (Permitir iot:Connect, iot:Publish, iot:Subscribe) e anexar ao certificado.

[ X ] Criar Fila SQS:

Nome: sentinel-ingestion-queue (Com Long Polling 20s e DLQ).

[ ] Criar Regra IoT (The Glue):

Ir em Message Routing > Rules.

Query: SELECT * FROM 'sentinel/telemetry'.

Action: Send a message to an SQS queue -> Selecionar sentinel-ingestion-queue.

[ ] Criar Tabela DynamoDB:

Nome: SentinelTelemetry (PK: deviceId, SK: timestamp).

FASE 2: O Novo Edge (Node-RED + MQTT) üè≠
[ ] Instalar N√≥ MQTT:

No Node-RED, garantir que o node network/mqtt est√° dispon√≠vel.

[ ] Configurar Conex√£o Segura:

Adicionar node mqtt out.

Server: Endpoint do seu AWS IoT Core (ex: a3xxx...amazonaws.com).

Porta: 8883.

TLS Configuration: Fazer upload dos 3 arquivos (Certificado, Private Key, CA) que voc√™ baixou na Fase 1.

[ ] Testar Envio:

T√≥pico: sentinel/telemetry.

Payload: JSON.

Valida√ß√£o: Verificar se a mensagem chega na fila SQS pelo console da AWS.

FASE 3: Processamento (Go & Serverless) ‚ö°
[ ] Criar Lambda em Go:

L√≥gica: Ler evento SQS -> Parse JSON -> Salvar no DynamoDB.

[ ] Deploy da Lambda:

Trigger: SQS sentinel-ingestion-queue.

Role IAM: Permiss√£o para ler SQS e escrever no DynamoDB.

FASE 4: Refatora√ß√£o do Backend (NestJS) üß†
[ ] Remover Ingest√£o HTTP:

O endpoint POST /telemetry do NestJS pode ser removido (ou mantido apenas como fallback/debug).

[ ] Implementar Leitura:

Criar servi√ßo no NestJS para ler dados do DynamoDB e servir para o Frontend via API Gateway.

[ ] Seguran√ßa:

Implementar Cognito Guard nas rotas do NestJS.

FASE 5: Frontend & Apresenta√ß√£o üíª
[ ] Integrar Login:

Tela de Login usando Cognito.

[ ] Visualiza√ß√£o:

Dashboard consumindo a API do NestJS (que agora l√™ do DynamoDB).